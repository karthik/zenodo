# private function to return root url of zenodo server
# in future could check a package option
zenodo_root<-function() "https://zenodo.org/"

#' http GET or POST request to Zenodo server using appropriate authentication
#'
#' @description \code{zen_fetch} carries out a GET operation when
#'   \code{body=NULL}, POST otherwise. The http status code of the response will
#'   be checked - if invalid an error will be thrown.
#'
#' @details Authentication is presently handled by the \code{\link{zen_pat}}
#'   function.
#'
#' @param path The path on the zenodo server relative to the zenodo root
#' @param body The (optional) body of the post request, usually in the form of a
#'   named list. See the \code{\link[httr]{POST}} documentation for full
#'   details.
#' @param parse.json Whether or not to parse a JSON response to an R object
#'   (default \code{TRUE})
#' @param include_headers Whether to include basic headers from the http request
#'   as attributes on the parsed JSON object (default \code{FALSE}).
#' @param zen_auth_params Named list of authentication parameters passed to
#'   zen_auth to override default authetication process.
#' @param parse_params Named list of parameters passed to
#'   \code{httr::\link[httr]{content}} function and then most likely on to
#'   \code{jsonlite::\link[jsonlite]{fromJSON}}.
#' @param ... Additional arguments passed to the \code{httr::GET} or
#'   \code{httr::POST} function
#' @return When \code{parse.json=FALSE} an object of class \code{response}
#'   otherwise the raw R object generated by calling \code{content(response,
#'   as='parsed')} on the body of the response.
#' @export
#' @seealso \code{\link{zen_pat}}, \code{\link[httr]{GET}},
#'   \code{\link[httr]{POST}}, \code{\link[jsonlite]{fromJSON}}
#' @importFrom httr GET POST content with_config config stop_for_status
#' @examples
#' \dontrun{
#' # Get list of depositions for current user
#' zen_fetch('api/deposit/depositions')
#'
#' # Get jsonlite to do some extra work on the result
#' # see ?fromJSON for details
#' zz=zen_fetch('api/deposit/depositions', parse_params = list(simplifyVector=TRUE))
#'
#' ## You can also PUT
#' # Here we take a sample JSON request  from the Zenodo API reference
#' # https://zenodo.org/dev#restapi-res-dep
#' json_request=paste0('{"metadata": {"title": "My first upload", "upload_type": "poster",',
#'   ' "description": "This is my first upload", "creators": [{"name": "Doe, John",',
#'   ' "affiliation": "Zenodo"}]}}')
#' # see what corresponding R list would look like
#' dput(fromJSON(d), control='useSource' )
#'
#' # now use that list as the body for a PUT
#' body=list(metadata = list(title = "My first upload", upload_type = "poster",
#'   description = "This is my first upload", creators = list(name = "Doe, John",
#'     affiliation = "Zenodo")))
#' zen_fetch('api/deposit/depositions', body=body)
#' }
zen_fetch<-function(path, body=NULL, parse.json=TRUE, include_headers=FALSE,
                    zen_auth_params=list(), parse_params=list(), ...) {
  pat=zen_pat()
  auth_config=list()
  if(is.null(pat)) {
    auth_config=do.call(zen_auth, zen_auth_params)
  } else {
    # we're using a PAT - this needs to be appended to the request path
    # see https://zenodo.org/dev#restapi-auth
    path=paste0(path,"?access_token=",pat)
    # make an empty config for convenience
    auth_config=config()
  }

  req<-with_config(auth_config, {
    if(is.null(body)) {
      GET(url=paste0(zenodo_root(), path), ...)
    } else {
      POST(url=paste0(zenodo_root(), path), body=body, ...)
    }
  } )
  # error out if there was a problem
  stop_for_status(req)
  if(parse.json) {
    parse_params[['as']]='parsed'
    parsed=do.call(content, c(list(req), parse_params))
    if(include_headers) {
      fields_to_include=c("url", "headers")
      attributes(parsed) = c(attributes(parsed), req[fields_to_include])
    }
    parsed
  } else req
}
